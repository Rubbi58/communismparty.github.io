<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Communism Party – Hóriver's Lair (Big Map)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #050104;
      color: #f7e3c8;
      overflow: hidden;
    }

    h1 {
      margin-top: 10px;
      text-align: center;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 18px;
      color: #ffdd88;
    }

    #subtitle {
      text-align: center;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-top: 4px;
      color: #ffbb66;
    }

    #game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: calc(100vh - 70px);
    }

    canvas {
      border: 2px solid #ffcc66;
      background: #000;
      image-rendering: pixelated;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
    }

    #controls {
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.9;
      color: #ffe6bf;
      text-align: center;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.88);
      z-index: 40;
    }
    .overlay.active {
      display: flex;
    }

    .overlay-card {
      border-radius: 1.4rem;
      border: 2px solid #ffcc66;
      background: radial-gradient(circle at top, #4b0000 0, #050104 60%);
      padding: 1.6rem 2rem 1.8rem;
      max-width: 480px;
      text-align: center;
      color: #ffe6bf;
      box-shadow: 0 26px 70px rgba(0, 0, 0, 0.9);
    }

    .overlay-card img {
      max-width: 260px;
      image-rendering: pixelated;
      border-radius: 0.7rem;
      margin-bottom: 0.9rem;
    }

    .overlay-title {
      font-size: 1.4rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: #ffdd88;
      margin-bottom: 0.5rem;
    }

    .overlay-sub {
      font-size: 0.92rem;
      margin-bottom: 1.1rem;
    }

    .btn {
      cursor: pointer;
      border-radius: 999px;
      padding: 0.6rem 1.5rem;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: none;
      margin: 0 0.4rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ffcc66, #ff4848);
      color: #3b0000;
      font-weight: 800;
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.7);
    }
    .btn-primary:hover {
      filter: brightness(1.06);
    }

    #alertBanner {
      position: fixed;
      left: 50%;
      top: 10%;
      transform: translateX(-50%);
      padding: 0.5rem 1.1rem;
      border-radius: 999px;
      border: 1px solid #ff4444;
      background: rgba(60, 0, 0, 0.93);
      color: #ffdddd;
      font-size: 0.82rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      text-align: center;
      display: none;
      z-index: 25;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.8);
    }

    #welcomeOverlay img {
      max-width: 280px;
    }

    #welcomeHint {
      margin-top: 0.8rem;
      font-size: 0.8rem;
      opacity: 0.7;
    }

    @media (max-width: 900px) {
      #game-wrapper {
        transform: scale(0.85);
      }
      .overlay-card {
        margin: 0 1rem;
        padding-inline: 1.4rem;
      }
    }
  </style>
</head>
<body>
  <h1>HÓRIVER’S LAIR – LEVEL 1</h1>
  <div id="subtitle">
    Mission: find the flashlight, key, vape and bathroom in Hóriver’s endless castle
  </div>

  <div id="game-wrapper">
    <canvas id="game" width="800" height="600"></canvas>
    <div id="controls">
      Move with <b>W A S D</b>. Closets = safe. Hóriver kills on contact. Fog is thick – use the flashlight.
    </div>
  </div>

  <div id="alertBanner">HÓRIVER HEARS YOU</div>

  <!-- WELCOME OVERLAY WITH TYPEWRITER -->
  <div id="welcomeOverlay" class="overlay active">
    <div class="overlay-card" id="welcomeCard">
      <div id="welcomeTextWrapper">
        <div class="overlay-title">COMMUNISM PARTY HQ</div>
        <div class="overlay-sub" id="welcomeText"></div>
        <div id="welcomeHint">Click this box to continue...</div>
      </div>
      <div id="welcomeFinal" style="display:none;">
        <img src="images/horiver-lair.png" alt="Horiver's Lair" />
        <div class="overlay-title">HORIVER'S LAIR</div>
        <div class="overlay-sub">Enter the cursed vape castle.</div>
        <button class="btn btn-primary" id="enterBtn">Enter</button>
      </div>
    </div>
  </div>

  <!-- Death overlay -->
  <div id="deathOverlay" class="overlay">
    <div class="overlay-card">
      <img src="images/horiver-jumpscare.png" alt="Horiver Jumpscare" />
      <div class="overlay-title" style="color:#ff5555;">WASTED</div>
      <div class="overlay-sub">
        Hóriver caught you in the fog. The castle reeks of vape forever.
      </div>
      <button class="btn btn-primary" id="retryBtn">Retry Level</button>
    </div>
  </div>

  <!-- Win overlay -->
  <div id="winOverlay" class="overlay">
    <div class="overlay-card">
      <img src="images/bhoriver-token.png" alt="Token" />
      <div class="overlay-title">MISSION COMPLETE</div>
      <div class="overlay-sub">
        The vape is flushed. Hóriver screams and dissolves into communist vapor. You claim your cursed token.
      </div>
      <button class="btn btn-primary" id="playAgainBtn">Play Again</button>
    </div>
  </div>

  <script>
    // ===== Helpers =====
    function makeImage(name) {
      const img = new Image();
      img.src = "images/" + encodeURIComponent(name);
      return img;
    }

    function makeSound(name, loop = false, volume = 1) {
      const a = new Audio("sounds/" + encodeURIComponent(name));
      a.loop = loop;
      a.volume = volume;
      return a;
    }

    function safePlay(a) {
      a.currentTime = 0;
      a.play().catch(() => {});
    }

    // ===== Canvas & world setup =====
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;
    const WORLD_W = 100;
    const WORLD_H = 100;

    const playerSpeed = 110;
    const horiverSpeed = 85;

    const T_WALL = 1;
    const T_FLOOR = 0;
    const T_CLOSET = 2;
    const T_THRONE = 3;
    const T_KEY = 4;
    const T_CHEST = 5;
    const T_BATHROOM = 6;
    const T_FLASHLIGHT = 7;
    const T_START = 8;

    const world = [];
    for (let y = 0; y < WORLD_H; y++) {
      const row = new Array(WORLD_W).fill(T_WALL);
      world.push(row);
    }

    function carveRect(x0, y0, x1, y1, type = T_FLOOR) {
      for (let y = y0; y <= y1; y++) {
        for (let x = x0; x <= x1; x++) {
          if (x > 0 && y > 0 && x < WORLD_W - 1 && y < WORLD_H - 1) {
            world[y][x] = type;
          }
        }
      }
    }

    function generateCastle() {
      carveRect(4, 4, WORLD_W - 5, 4);
      carveRect(4, WORLD_H - 5, WORLD_W - 5, WORLD_H - 5);
      carveRect(4, 4, 4, WORLD_H - 5);
      carveRect(WORLD_W - 5, 4, WORLD_W - 5, WORLD_H - 5);

      carveRect(10, WORLD_H / 2 - 1, WORLD_W - 11, WORLD_H / 2 + 1);
      carveRect(WORLD_W / 2 - 1, 10, WORLD_W / 2 + 1, WORLD_H - 11);

      for (let i = 0; i < 10; i++) {
        const rx = 8 + i * 8;
        carveRect(rx, 15, rx + 4, 20);
        carveRect(rx, WORLD_H - 21, rx + 4, WORLD_H - 16);
      }
      for (let i = 0; i < 10; i++) {
        const ry = 8 + i * 8;
        carveRect(15, ry, 20, ry + 4);
        carveRect(WORLD_W - 21, ry, WORLD_W - 16, ry + 4);
      }

      for (let i = 0; i < 40; i++) {
        const x = 6 + Math.floor(Math.random() * (WORLD_W - 12));
        const y = 6 + Math.floor(Math.random() * (WORLD_H - 12));
        if (Math.random() < 0.5) {
          carveRect(x, y, x + 7, y + 1);
        } else {
          carveRect(x, y, x + 1, y + 7);
        }
      }

      world[WORLD_H - 8][10] = T_START;
      world[WORLD_H - 12][16] = T_FLASHLIGHT;
      world[10][WORLD_W - 12] = T_THRONE;
      world[18][18] = T_KEY;
      world[WORLD_H - 18][WORLD_W - 20] = T_CHEST;
      world[8][Math.floor(WORLD_W / 2)] = T_BATHROOM;

      const closetPositions = [
        [WORLD_W / 2 - 4, WORLD_H / 2 - 6],
        [WORLD_W / 2 + 5, WORLD_H / 2 + 3],
        [14, WORLD_H / 2 + 4],
        [WORLD_W - 16, WORLD_H / 2 - 3]
      ];
      closetPositions.forEach(([x, y]) => {
        world[Math.floor(y)][Math.floor(x)] = T_CLOSET;
      });
    }

    generateCastle();

    function tileAt(tx, ty) {
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return T_WALL;
      return world[ty][tx];
    }

    function isWalkable(tx, ty) {
      return tileAt(tx, ty) !== T_WALL;
    }

    function findTile(type) {
      for (let y = 0; y < WORLD_H; y++) {
        for (let x = 0; x < WORLD_W; x++) {
          if (world[y][x] === type) return { x, y };
        }
      }
      return null;
    }

    // ===== Assets =====
    const imgTiles = makeImage("dungeons-pack.png");
    const imgPlayer = makeImage("player.png");
    const imgHoriver = makeImage("horiver-character.png");
    const imgFlashlight = makeImage("pixel-flashlight.png");
    const imgKey = makeImage("key pixel.png");
    const imgVape = makeImage("vape pixel.png");

    const SHEET_TILE = 16;
    const tileSrc = {
      floor: { sx: 16, sy: 16 },
      wall: { sx: 16 * 4, sy: 16 },
      closet: { sx: 16 * 6, sy: 16 * 3 },
      bathroom: { sx: 16 * 8, sy: 16 * 2 }
    };

    const sounds = {
      bgm: makeSound("backg-music.mp3", true, 0.4),
      start: makeSound("start-sound.mp3"),
      menuClick: makeSound("menu-click.mp3"),
      pickup: makeSound("item-pickup.mp3"),
      door: makeSound("door-open.mp3"),
      flush: makeSound("toilet-flush.mp3"),
      jumpscare: makeSound("jumpscare.mp3"),
      win: makeSound("win.mp3"),
      deathScream: makeSound("horiver-death-scream.mp3")
    };

    let musicStarted = false;
    function startMusicOnce() {
      if (!musicStarted) {
        musicStarted = true;
        safePlay(sounds.bgm);
      }
    }

    // ===== Game state =====
    let player = { x: 0, y: 0, vx: 0, vy: 0 };
    let horiver = { x: 0, y: 0, vx: 0, vy: 0, active: false, alive: true };
    let keys = { w: false, a: false, s: false, d: false };
    let lastDir = { x: 0, y: 1 };

    let haveFlashlight = false;
    let haveKey = false;
    let haveVape = false;
    let vapeDestroyed = false;
    let gameOver = false;
    let win = false;

    function resetGame() {
      const startTile = findTile(T_START) || { x: 10, y: WORLD_H - 8 };
      player.x = (startTile.x + 0.5) * TILE;
      player.y = (startTile.y + 0.5) * TILE;
      player.vx = player.vy = 0;

      const throne = findTile(T_THRONE) || { x: WORLD_W - 12, y: 10 };
      horiver.x = (throne.x + 0.5) * TILE;
      horiver.y = (throne.y + 0.5) * TILE;
      horiver.vx = horiver.vy = 0;
      horiver.active = false;
      horiver.alive = true;

      haveFlashlight = false;
      haveKey = false;
      haveVape = false;
      vapeDestroyed = false;
      gameOver = false;
      win = false;

      document.getElementById("subtitle").textContent =
        "Mission: find the flashlight, key, vape and bathroom in Hóriver’s endless castle";

      hideAlert();
    }

    // ===== Input =====
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "s") keys.s = true;
      if (k === "a") keys.a = true;
      if (k === "d") keys.d = true;
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "s") keys.s = false;
      if (k === "a") keys.a = false;
      if (k === "d") keys.d = false;
    });

    // ===== Alert banner =====
    function showAlert() {
      const el = document.getElementById("alertBanner");
      el.style.display = "block";
      setTimeout(() => {
        el.style.display = "none";
      }, 2000);
    }

    function hideAlert() {
      document.getElementById("alertBanner").style.display = "none";
    }

    function awakenHoriver() {
      if (!horiver.active && horiver.alive) {
        horiver.active = true;
        showAlert();
        safePlay(sounds.jumpscare);
      }
    }

    function isCloset(tx, ty) {
      return tileAt(tx, ty) === T_CLOSET;
    }

    function pickupCheck() {
      const tx = Math.floor(player.x / TILE);
      const ty = Math.floor(player.y / TILE);
      const t = tileAt(tx, ty);

      if (t === T_FLASHLIGHT && !haveFlashlight) {
        haveFlashlight = true;
        world[ty][tx] = T_FLOOR;
        safePlay(sounds.pickup);
        document.getElementById("subtitle").textContent =
          "Mission: find the key to Hóriver’s chest";
      }

      if (t === T_KEY && !haveKey) {
        haveKey = true;
        world[ty][tx] = T_FLOOR;
        safePlay(sounds.pickup);
        awakenHoriver();
        document.getElementById("subtitle").textContent =
          "Mission: reach the chest and steal the vape";
      }

      if (t === T_CHEST && haveKey && !haveVape && !vapeDestroyed) {
        haveVape = true;
        safePlay(sounds.door);
        safePlay(sounds.pickup);
        document.getElementById("subtitle").textContent =
          "Mission: find the bathroom and flush the vape";
      }

      if (t === T_BATHROOM && haveVape && !vapeDestroyed) {
        haveVape = false;
        vapeDestroyed = true;
        safePlay(sounds.flush);
        safePlay(sounds.deathScream);
        horiver.alive = false;
        horiver.active = false;
        document.getElementById("subtitle").textContent =
          "Mission: return to the throne to claim your reward";
      }

      if (t === T_THRONE && vapeDestroyed && !win) {
        finishLevel();
      }
    }

    function finishLevel() {
      win = true;
      safePlay(sounds.win);
      document.getElementById("winOverlay").classList.add("active");
    }

    function killPlayer() {
      if (gameOver || win) return;
      gameOver = true;
      safePlay(sounds.jumpscare);
      document.getElementById("deathOverlay").classList.add("active");
    }

    function moveEntity(ent, dt) {
      const nextX = ent.x + ent.vx * dt;
      const nextY = ent.y + ent.vy * dt;

      const txNewX = Math.floor(nextX / TILE);
      const tyCur = Math.floor(ent.y / TILE);
      if (isWalkable(txNewX, tyCur)) {
        ent.x = nextX;
      } else {
        ent.vx = 0;
      }

      const txCur = Math.floor(ent.x / TILE);
      const tyNewY = Math.floor(nextY / TILE);
      if (isWalkable(txCur, tyNewY)) {
        ent.y = nextY;
      } else {
        ent.vy = 0;
      }
    }

    function updateMovement(dt) {
      let dx = 0;
      let dy = 0;
      if (keys.w) dy -= 1;
      if (keys.s) dy += 1;
      if (keys.a) dx -= 1;
      if (keys.d) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len;
        dy /= len;
        player.vx = dx * playerSpeed;
        player.vy = dy * playerSpeed;
        lastDir.x = dx;
        lastDir.y = dy;
      } else {
        player.vx = player.vy = 0;
      }

      moveEntity(player, dt);
      pickupCheck();
    }

    function updateHoriver(dt) {
      if (!horiver.active || !horiver.alive) return;

      const dx = player.x - horiver.x;
      const dy = player.y - horiver.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 1) {
        const dirX = dx / dist;
        const dirY = dy / dist;
        horiver.vx = dirX * horiverSpeed;
        horiver.vy = dirY * horiverSpeed;
      } else {
        horiver.vx = horiver.vy = 0;
      }

      moveEntity(horiver, dt);

      const ptx = Math.floor(player.x / TILE);
      const pty = Math.floor(player.y / TILE);
      const htx = Math.floor(horiver.x / TILE);
      const hty = Math.floor(horiver.y / TILE);

      if (ptx === htx && pty === hty && !isCloset(ptx, pty) && !vapeDestroyed) {
        killPlayer();
      }
    }

    function getCamera() {
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;

      const maxX = WORLD_W * TILE - canvas.width;
      const maxY = WORLD_H * TILE - canvas.height;

      camX = Math.max(0, Math.min(camX, maxX));
      camY = Math.max(0, Math.min(camY, maxY));

      return { x: camX, y: camY };
    }

    function drawTileFromSheet(type, sx, sy, dx, dy) {
      if (imgTiles.complete && imgTiles.naturalWidth) {
        ctx.drawImage(imgTiles, sx, sy, SHEET_TILE, SHEET_TILE, dx, dy, TILE, TILE);
      } else {
        if (type === T_WALL) ctx.fillStyle = "#3b1517";
        else ctx.fillStyle = "#15060a";
        ctx.fillRect(dx, dy, TILE, TILE);
      }
    }

    function render() {
      const cam = getCamera();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const startTX = Math.floor(cam.x / TILE);
      const startTY = Math.floor(cam.y / TILE);
      const endTX = Math.ceil((cam.x + canvas.width) / TILE);
      const endTY = Math.ceil((cam.y + canvas.height) / TILE);

      for (let ty = startTY; ty <= endTY; ty++) {
        for (let tx = startTX; tx <= endTX; tx++) {
          const t = tileAt(tx, ty);
          const sx = tx * TILE - cam.x;
          const sy = ty * TILE - cam.y;

          if (t === T_WALL) {
            drawTileFromSheet(T_WALL, tileSrc.wall.sx, tileSrc.wall.sy, sx, sy);
          } else if (t === T_CLOSET) {
            drawTileFromSheet(T_FLOOR, tileSrc.closet.sx, tileSrc.closet.sy, sx, sy);
          } else if (t === T_BATHROOM) {
            drawTileFromSheet(T_FLOOR, tileSrc.bathroom.sx, tileSrc.bathroom.sy, sx, sy);
          } else {
            drawTileFromSheet(T_FLOOR, tileSrc.floor.sx, tileSrc.floor.sy, sx, sy);
          }

          if (t === T_THRONE) {
            ctx.fillStyle = "#553322";
            ctx.fillRect(sx + 6, sy + 6, TILE - 12, TILE - 12);
          }
        }
      }

      function drawSprite(img, gx, gy, scale = 0.8) {
        const screenX = gx * TILE - cam.x;
        const screenY = gy * TILE - cam.y;
        const size = TILE * scale;
        const dx = screenX + (TILE - size) / 2;
        const dy = screenY + (TILE - size) / 2;
        if (screenX + TILE < 0 || screenY + TILE < 0 || screenX > canvas.width || screenY > canvas.height) return;

        if (img.complete && img.naturalWidth) {
          ctx.drawImage(img, dx, dy, size, size);
        } else {
          ctx.fillStyle = "#0cf";
          ctx.fillRect(dx, dy, size, size);
        }
      }

      for (let ty = startTY; ty <= endTY; ty++) {
        for (let tx = startTX; tx <= endTX; tx++) {
          const t = tileAt(tx, ty);
          if (t === T_FLASHLIGHT && !haveFlashlight) drawSprite(imgFlashlight, tx, ty, 0.85);
          if (t === T_KEY && !haveKey) drawSprite(imgKey, tx, ty, 0.9);
          if (t === T_CHEST && haveKey && !vapeDestroyed && !haveVape) drawSprite(imgVape, tx, ty, 0.8);
        }
      }

      drawSprite(imgPlayer, player.x / TILE, player.y / TILE, 0.9);
      if (horiver.alive && horiver.active) {
        drawSprite(imgHoriver, horiver.x / TILE, horiver.y / TILE, 0.9);
      }

      applyFog(cam, player.x - cam.x, player.y - cam.y);
    }

    function applyFog(cam, pScreenX, pScreenY) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.96)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = "destination-out";

      const baseRadius = haveFlashlight ? 90 : 60;
      ctx.beginPath();
      ctx.arc(pScreenX, pScreenY, baseRadius, 0, Math.PI * 2);
      ctx.fill();

      const dirLen = Math.hypot(lastDir.x, lastDir.y) || 1;
      const fx = pScreenX + (lastDir.x / dirLen) * 160;
      const fy = pScreenY + (lastDir.y / dirLen) * 160;
      const flashlightRadius = haveFlashlight ? 160 : 90;

      ctx.beginPath();
      ctx.arc(fx, fy, flashlightRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // ===== Main loop =====
    let lastTime = performance.now();
    function loop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;

      if (!gameOver && !win && !document.getElementById("welcomeOverlay").classList.contains("active")) {
        updateMovement(dt);
        updateHoriver(dt);
        render();
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== Overlays & typewriter intro =====
    const welcomeOverlay = document.getElementById("welcomeOverlay");
    const welcomeCard = document.getElementById("welcomeCard");
    const welcomeTextEl = document.getElementById("welcomeText");
    const welcomeHintEl = document.getElementById("welcomeHint");
    const welcomeTextWrapper = document.getElementById("welcomeTextWrapper");
    const welcomeFinal = document.getElementById("welcomeFinal");
    const enterBtn = document.getElementById("enterBtn");

    const deathOverlay = document.getElementById("deathOverlay");
    const winOverlay = document.getElementById("winOverlay");

    const welcomeMessages = [
      "Welcome to Hubios communism party game. Your mission is to save communism Iceland, but first, you need to defeat some foes...",
      "Now you'll enter... Horivers lair!!!",
      "Are you ready?"
    ];
    let welcomeStep = 0;
    let typingIndex = 0;
    let typingTimer = null;
    let typingDone = false;

    function typeNextChar() {
      const msg = welcomeMessages[welcomeStep];
      if (typingIndex <= msg.length) {
        welcomeTextEl.textContent = msg.slice(0, typingIndex);
        typingIndex++;
      } else {
        clearInterval(typingTimer);
        typingTimer = null;
        typingDone = true;
        welcomeHintEl.textContent = "Click this box to continue...";
      }
    }

    function startTyping() {
      if (typingTimer) clearInterval(typingTimer);
      typingIndex = 0;
      typingDone = false;
      welcomeTextEl.textContent = "";
      welcomeHintEl.textContent = "";
      typingTimer = setInterval(typeNextChar, 35);
    }

    startTyping(); // start first message immediately

    welcomeCard.addEventListener("click", () => {
      startMusicOnce(); // start bgm on first interaction

      if (!typingDone) {
        // fast-finish the current message
        const msg = welcomeMessages[welcomeStep];
        clearInterval(typingTimer);
        typingTimer = null;
        typingDone = true;
        typingIndex = msg.length;
        welcomeTextEl.textContent = msg;
        welcomeHintEl.textContent = "Click this box to continue...";
        return;
      }

      welcomeStep++;
      if (welcomeStep < welcomeMessages.length) {
        startTyping();
      } else {
        // show final Horiver Lair screen
        welcomeTextWrapper.style.display = "none";
        welcomeFinal.style.display = "block";
      }
    });

    enterBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      safePlay(sounds.menuClick);
      startMusicOnce();
      welcomeOverlay.classList.remove("active");
      resetGame();
      safePlay(sounds.start);
    });

    document.getElementById("retryBtn").addEventListener("click", () => {
      safePlay(sounds.menuClick);
      deathOverlay.classList.remove("active");
      resetGame();
    });

    document.getElementById("playAgainBtn").addEventListener("click", () => {
      safePlay(sounds.menuClick);
      winOverlay.classList.remove("active");
      resetGame();
    });

    // initial render
    render();
  </script>
</body>
</html>
