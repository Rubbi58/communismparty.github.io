<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Communism Party – Hóriver's Lair (Final Castle)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #050104;
      color: #f7e3c8;
      overflow: hidden;
    }

    h1 {
      margin-top: 10px;
      text-align: center;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 18px;
      color: #ffdd88;
    }

    #subtitle {
      text-align: center;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-top: 4px;
      color: #ffbb66;
    }

    #game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: calc(100vh - 90px);
    }

    canvas {
      border: 2px solid #ffcc66;
      background: #000;
      image-rendering: pixelated;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
    }

    #controls {
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.9;
      color: #ffe6bf;
      text-align: center;
    }

    #interactionPrompt {
      margin-top: 4px;
      font-size: 13px;
      text-align: center;
      color: #ffdd88;
      min-height: 18px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.88);
      z-index: 40;
    }
    .overlay.active {
      display: flex;
    }

    .overlay-card {
      border-radius: 1.4rem;
      border: 2px solid #ffcc66;
      background: radial-gradient(circle at top, #4b0000 0, #050104 60%);
      padding: 1.6rem 2rem 1.8rem;
      max-width: 480px;
      text-align: center;
      color: #ffe6bf;
      box-shadow: 0 26px 70px rgba(0, 0, 0, 0.9);
    }

    .overlay-card img {
      max-width: 260px;
      image-rendering: pixelated;
      border-radius: 0.7rem;
      margin-bottom: 0.9rem;
    }

    .overlay-title {
      font-size: 1.4rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: #ffdd88;
      margin-bottom: 0.5rem;
    }

    .overlay-sub {
      font-size: 0.92rem;
      margin-bottom: 1.1rem;
    }

    .btn {
      cursor: pointer;
      border-radius: 999px;
      padding: 0.6rem 1.5rem;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: none;
      margin: 0 0.4rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ffcc66, #ff4848);
      color: #3b0000;
      font-weight: 800;
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.7);
    }
    .btn-primary:hover {
      filter: brightness(1.06);
    }

    #alertBanner {
      position: fixed;
      left: 50%;
      top: 10%;
      transform: translateX(-50%);
      padding: 0.5rem 1.1rem;
      border-radius: 999px;
      border: 1px solid #ff4444;
      background: rgba(60, 0, 0, 0.93);
      color: #ffdddd;
      font-size: 0.82rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      text-align: center;
      display: none;
      z-index: 25;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.8);
    }

    #welcomeOverlay img {
      max-width: 280px;
    }

    #welcomeHint {
      margin-top: 0.8rem;
      font-size: 0.8rem;
      opacity: 0.7;
    }

    @media (max-width: 900px) {
      #game-wrapper {
        transform: scale(0.85);
      }
      .overlay-card {
        margin: 0 1rem;
        padding-inline: 1.4rem;
      }
    }
  </style>
</head>
<body>
  <h1>HÓRIVER’S LAIR – LEVEL 1 (FINAL)</h1>
  <div id="subtitle">
    Mission: find the flashlight, key, vape and bathroom in Hóriver’s cursed mega-mansion–castle
  </div>

  <div id="game-wrapper">
    <canvas id="game" width="800" height="600"></canvas>
    <div id="controls">
      Move with <b>W A S D</b>. <b>E</b> = interact (pick up, flush, claim). <b>F</b> = hide in closets.
      Hóriver kills on contact.
    </div>
    <div id="interactionPrompt"></div>
  </div>

  <div id="alertBanner">HÓRIVER HEARS YOU</div>

  <!-- WELCOME OVERLAY WITH TYPEWRITER -->
  <div id="welcomeOverlay" class="overlay active">
    <div class="overlay-card" id="welcomeCard">
      <div id="welcomeTextWrapper">
        <div class="overlay-title">COMMUNISM PARTY HQ</div>
        <div class="overlay-sub" id="welcomeText"></div>
        <div id="welcomeHint">Click this box to continue...</div>
      </div>
      <div id="welcomeFinal" style="display:none;">
        <img src="images/horiver-lair.png" alt="Horiver's Lair" />
        <div class="overlay-title">HORIVER'S LAIR</div>
        <div class="overlay-sub">Enter the cursed vape castle.</div>
        <button class="btn btn-primary" id="enterBtn">Enter</button>
      </div>
    </div>
  </div>

  <!-- Death overlay -->
  <div id="deathOverlay" class="overlay">
    <div class="overlay-card">
      <img src="images/horiver-jumpscare.png" alt="Horiver Jumpscare" />
      <div class="overlay-title" style="color:#ff5555;">WASTED</div>
      <div class="overlay-sub">
        Hóriver caught you in the fog. The castle reeks of vape forever.
      </div>
      <button class="btn btn-primary" id="retryBtn">Retry Level</button>
    </div>
  </div>

  <!-- Win overlay -->
  <div id="winOverlay" class="overlay">
    <div class="overlay-card">
      <img src="images/bhoriver-token.png" alt="Token" />
      <div class="overlay-title">MISSION COMPLETE</div>
      <div class="overlay-sub">
        The vape is flushed. Hóriver screams and dissolves into communist vapor. You claim your cursed token.
      </div>
      <button class="btn btn-primary" id="playAgainBtn">Play Again</button>
    </div>
  </div>

  <script>
    // ===== Helpers =====
    function makeImage(name) {
      const img = new Image();
      img.src = "images/" + encodeURIComponent(name);
      return img;
    }

    function makeSound(name, loop = false, volume = 1) {
      const a = new Audio("sounds/" + encodeURIComponent(name));
      a.loop = loop;
      a.volume = volume;
      return a;
    }

    function safePlay(a) {
      try {
        a.currentTime = 0;
        a.play().catch(() => {});
      } catch (e) {}
    }

    // ===== Canvas & world =====
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;
    const WORLD_W = 50;
    const WORLD_H = 50;

    const playerSpeed = 140;
    const horiverBaseSpeed = 90;

    const T_WALL = 1;
    const T_FLOOR = 0;
    const T_CLOSET = 2;
    const T_THRONE = 3;
    const T_KEY = 4;
    const T_CHEST = 5;
    const T_BATHROOM = 6;
    const T_FLASHLIGHT = 7;
    const T_START = 8;

    const world = [];
    for (let y = 0; y < WORLD_H; y++) {
      const row = new Array(WORLD_W).fill(T_WALL);
      world.push(row);
    }

    function inBounds(x, y) {
      return x > 0 && y > 0 && x < WORLD_W - 1 && y < WORLD_H - 1;
    }

    function carveRect(x0, y0, x1, y1, tileType = T_FLOOR) {
      for (let y = y0; y <= y1; y++) {
        for (let x = x0; x <= x1; x++) {
          if (inBounds(x, y)) {
            world[y][x] = tileType;
          }
        }
      }
    }

    function tileAt(tx, ty) {
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return T_WALL;
      return world[ty][tx];
    }

    function isWalkable(tx, ty) {
      const t = tileAt(tx, ty);
      return t !== T_WALL;
    }

    // deterministic random from coords (for cobble cracks)
    function coordRand(x, y, seed = 1337) {
      let n = x * 374761393 + y * 668265263 + seed * 1442695040888963407;
      n = (n ^ (n >> 13)) * 1274126177;
      n = (n ^ (n >> 16));
      return (n >>> 0) / 4294967295;
    }

    // ===== Assets =====
    // Player directional sprites:
    const imgPlayerLeft  = makeImage("player.png");
    const imgPlayerRight = makeImage("player-right.png");
    const imgPlayerUp    = makeImage("player-up.png");
    const imgPlayerDown  = makeImage("player-down.png");

    // Horiver directional sprites:
    const imgHoriverLeft  = makeImage("horiver-character.png");
    const imgHoriverRight = makeImage("horiver-right.png");
    const imgHoriverUp    = makeImage("horiver-up.png");
    const imgHoriverDown  = makeImage("horiver-down.png");

    // tiles
    const imgCobble       = makeImage("cobble.png");
    const imgCobbleCrack  = makeImage("cobble-crack.png");
    const imgCobbleDark   = makeImage("cobble-dark.png");

    // furniture
    const imgStove        = makeImage("stove.png");
    const imgTable        = makeImage("table.png");
    const imgArmorStand   = makeImage("armor-stand.png");
    const imgWeaponStand  = makeImage("weapon-stand.png");
    const imgBed          = makeImage("bed.png");
    const imgMedBed       = makeImage("medical-bed.png");
    const imgMedShelf     = makeImage("medical-shelf.png");
    const imgCloset       = makeImage("closet.png");
    const imgThrone       = makeImage("throne.png");
    const imgBath         = makeImage("bath.png");
    const imgToilet       = makeImage("toilet.png");
    const imgSink         = makeImage("sink.png");

    // items & HUD
    const imgFlashlight   = makeImage("pixel-flashlight.png");
    const imgKey          = makeImage("key pixel.png");
    const imgVape         = makeImage("vape pixel.png");
    const imgHUDFlashlight = imgFlashlight;
    const imgHUDKey       = imgKey;
    const imgHUDVape      = imgVape;
    const imgHUDToken     = makeImage("bhoriver-token.png");

    const sounds = {
      bgm: makeSound("backg-music.mp3", true, 0.45),
      start: makeSound("start-sound.mp3"),
      menuClick: makeSound("menu-click.mp3"),
      pickup: makeSound("item-pickup.mp3"),
      door: makeSound("door-open.mp3"),
      flush: makeSound("toilet-flush.mp3"),
      jumpscare: makeSound("jumpscare.mp3"),
      win: makeSound("win.mp3"),
      deathScream: makeSound("horiver-death-scream.mp3"),
      footsteps: makeSound("footsteps.mp3", true, 0.28),
      heartbeat: makeSound("heartbeat.mp3", true, 0.6)
    };

    let musicStarted = false;
    function startMusicOnce() {
      if (!musicStarted) {
        musicStarted = true;
        safePlay(sounds.bgm);
      }
    }

    let footstepsPlaying = false;
    function playFootsteps() {
      if (!footstepsPlaying) {
        sounds.footsteps.play().catch(() => {});
        footstepsPlaying = true;
      }
    }
    function stopFootsteps() {
      if (footstepsPlaying) {
        sounds.footsteps.pause();
        footstepsPlaying = false;
      }
    }

    let heartbeatPlaying = false;
    function playHeartbeat() {
      if (!heartbeatPlaying) {
        sounds.heartbeat.play().catch(() => {});
        heartbeatPlaying = true;
      }
    }
    function stopHeartbeat() {
      if (heartbeatPlaying) {
        sounds.heartbeat.pause();
        heartbeatPlaying = false;
      }
    }

    // ===== Game state =====
    let player = { x: 0, y: 0, vx: 0, vy: 0 };
    let playerFacing = "down";

    let horiver = {
      x: 0, y: 0, vx: 0, vy: 0,
      active: false, alive: true,
      state: "patrol",
      patrolIndex: 0,
      lastKnownX: 0,
      lastKnownY: 0,
      searchTimer: 0,
      timeSinceSeen: 0
    };
    let horiverFacingVec = { x: 0, y: 1 };

    let keysState = { w: false, a: false, s: false, d: false };

    let haveFlashlight = false;
    let haveKey = false;
    let haveVape = false;
    let vapeDestroyed = false;
    let gameOver = false;
    let win = false;

    let playerHidden = false;
    let closetNearby = false;
    let closetTile = null;
    let hideReturnPos = null;

    let interactionPrompt = "";
    let interactionAction = null;
    const interactionEl = document.getElementById("interactionPrompt");

    // room info for furniture
    const rooms = {
      bathroom: null,
      bedroomLeft: null,
      bedroomRight: null,
      armory: null,
      kitchen: null,
      infirmary: null,
      laboratory: null,
      throne: null
    };

    // furniture placement
    const furn = {
      beds: [],
      closets: [],
      stoves: [],
      tables: [],
      armorStands: [],
      weaponStands: [],
      medBeds: [],
      medShelves: [],
      sinks: [],
      baths: [],
      toilets: []
    };

    // patrol points for Horiver
    const patrolPoints = [];

    function clearInteraction() {
      interactionPrompt = "";
      interactionAction = null;
      interactionEl.textContent = "";
    }

    function setRoom(name, x0, y0, x1, y1) {
      rooms[name] = { x0, y0, x1, y1 };
      const cx = Math.floor((x0 + x1) / 2);
      const cy = Math.floor((y0 + y1) / 2);
      patrolPoints.push({ x: cx, y: cy });
    }

    // ===== Layout generation based on blueprint =====
    function generateCastle() {
      // main vertical hallway
      const cx = Math.floor(WORLD_W / 2); // center X
      const hallX0 = cx - 1;
      const hallX1 = cx + 1;
      const hallTop = 5;
      const hallBottom = 40;
      carveRect(hallX0, hallTop, hallX1, hallBottom);

      // player start corridor (top-left of hall)
      carveRect(hallX0 - 6, hallTop - 3, hallX0 - 2, hallTop - 1); // little player room
      carveRect(hallX0 - 2, hallTop - 2, hallX0, hallTop); // corridor into hall
      const startTx = hallX0 - 5;
      const startTy = hallTop - 2;
      if (inBounds(startTx, startTy)) {
        world[startTy][startTx] = T_START;
      }

      // throne room (bottom)
      const throneX0 = cx - 8;
      const throneX1 = cx + 8;
      const throneY0 = hallBottom + 1;
      const throneY1 = hallBottom + 7;
      carveRect(throneX0, throneY0, throneX1, throneY1);
      setRoom("throne", throneX0, throneY0, throneX1, throneY1);
      const throneTx = cx;
      const throneTy = throneY0 + 1;
      if (inBounds(throneTx, throneTy)) {
        world[throneTy][throneTx] = T_THRONE;
      }
      // open big doorway between hall and throne room
      carveRect(hallX0, hallBottom, hallX1, hallBottom + 1);

      // LEFT WING ROOMS: bathroom, bedroom, armory
      // Bathroom (upper left)
      const bathX1 = hallX0 - 3;
      const bathX0 = bathX1 - 7;
      const bathY0 = hallTop + 2;
      const bathY1 = bathY0 + 6;
      carveRect(bathX0, bathY0, bathX1, bathY1);
      setRoom("bathroom", bathX0, bathY0, bathX1, bathY1);
      // corridor from hall to bathroom
      carveRect(bathX1 + 1, bathY0 + 2, hallX0 - 1, bathY0 + 3);

      // Left bedroom (middle left)
      const bedLX1 = hallX0 - 3;
      const bedLX0 = bedLX1 - 8;
      const bedLY0 = bathY1 + 2;
      const bedLY1 = bedLY0 + 8;
      carveRect(bedLX0, bedLY0, bedLX1, bedLY1);
      setRoom("bedroomLeft", bedLX0, bedLY0, bedLX1, bedLY1);
      carveRect(bedLX1 + 1, bedLY0 + 3, hallX0 - 1, bedLY0 + 4);

      // Armory (lower left)
      const armX1 = hallX0 - 3;
      const armX0 = armX1 - 8;
      const armY0 = bedLY1 + 2;
      const armY1 = armY0 + 8;
      carveRect(armX0, armY0, armX1, armY1);
      setRoom("armory", armX0, armY0, armX1, armY1);
      carveRect(armX1 + 1, armY0 + 3, hallX0 - 1, armY0 + 4);

      // RIGHT WING ROOMS: bedroom, kitchen, infirmary, laboratory
      // Right bedroom (upper right)
      const bedRX0 = hallX1 + 3;
      const bedRX1 = bedRX0 + 8;
      const bedRY0 = hallTop + 4;
      const bedRY1 = bedRY0 + 8;
      carveRect(bedRX0, bedRY0, bedRX1, bedRY1);
      setRoom("bedroomRight", bedRX0, bedRY0, bedRX1, bedRY1);
      carveRect(hallX1 + 1, bedRY0 + 3, bedRX0 - 1, bedRY0 + 4);

      // Kitchen (mid right)
      const kitX0 = hallX1 + 3;
      const kitX1 = kitX0 + 8;
      const kitY0 = bedRY1 + 2;
      const kitY1 = kitY0 + 8;
      carveRect(kitX0, kitY0, kitX1, kitY1);
      setRoom("kitchen", kitX0, kitY0, kitX1, kitY1);
      carveRect(hallX1 + 1, kitY0 + 3, kitX0 - 1, kitY0 + 4);

      // Infirmary (lower mid right)
      const infX0 = hallX1 + 3;
      const infX1 = infX0 + 8;
      const infY0 = kitY1 + 2;
      const infY1 = infY0 + 8;
      carveRect(infX0, infY0, infX1, infY1);
      setRoom("infirmary", infX0, infY0, infX1, infY1);
      carveRect(hallX1 + 1, infY0 + 3, infX0 - 1, infY0 + 4);

      // Laboratory (bottom right)
      const labX0 = hallX1 + 3;
      const labX1 = labX0 + 8;
      const labY0 = infY1 + 2;
      const labY1 = labY0 + 8;
      carveRect(labX0, labY0, labX1, labY1);
      setRoom("laboratory", labX0, labY0, labX1, labY1);
      carveRect(hallX1 + 1, labY0 + 3, labX0 - 1, labY0 + 4);

      // Extra patrol points in main hall
      patrolPoints.push({ x: cx, y: Math.floor((hallTop + hallBottom) / 2) });
      patrolPoints.push({ x: cx, y: hallBottom - 1 });

      // --- Place special tiles & furniture ---

      // Bathroom fixtures (layout A)
      if (rooms.bathroom) {
        const r = rooms.bathroom;
        const midX = Math.floor((r.x0 + r.x1) / 2);
        const backY = r.y0 + 1;

        // sink left, bath center, toilet right
        furn.sinks.push({ x: r.x0 + 1, y: backY });
        furn.baths.push({ x: midX, y: backY });
        furn.toilets.push({ x: r.x1 - 1, y: backY });

        // interactive bathroom tile at toilet
        world[backY][r.x1 - 1] = T_BATHROOM;
      }

      // Left bedroom furniture: bed + closet + flashlight
      if (rooms.bedroomLeft) {
        const r = rooms.bedroomLeft;
        const bedX = r.x0 + 2;
        const bedY = r.y0 + 2;
        furn.beds.push({ x: bedX, y: bedY });

        const closetX = r.x1 - 2;
        const closetY = r.y0 + 2;
        furn.closets.push({ x: closetX, y: closetY });
        world[closetY][closetX] = T_CLOSET;

        // flashlight spawn near bed
        const fx = bedX + 1;
        const fy = bedY;
        if (inBounds(fx, fy)) world[fy][fx] = T_FLASHLIGHT;
      }

      // Right bedroom furniture
      if (rooms.bedroomRight) {
        const r = rooms.bedroomRight;
        const bedX = r.x1 - 2;
        const bedY = r.y0 + 2;
        furn.beds.push({ x: bedX, y: bedY });

        // optional extra closet
        const closetX = r.x0 + 2;
        const closetY = r.y0 + 2;
        furn.closets.push({ x: closetX, y: closetY });
        world[closetY][closetX] = T_CLOSET;
      }

      // Armory furniture + chest (with vape later)
      if (rooms.armory) {
        const r = rooms.armory;
        furn.armorStands.push({ x: r.x0 + 1, y: r.y0 + 2 });
        furn.weaponStands.push({ x: r.x1 - 2, y: r.y0 + 2 });

        // chest tile (table with vape) near back
        const chestX = Math.floor((r.x0 + r.x1) / 2);
        const chestY = r.y0 + 3;
        world[chestY][chestX] = T_CHEST;
      }

      // Kitchen furniture + key
      if (rooms.kitchen) {
        const r = rooms.kitchen;
        const stoveX = r.x0 + 1;
        const stoveY = r.y0 + 1;
        furn.stoves.push({ x: stoveX, y: stoveY });

        const tableX = Math.floor((r.x0 + r.x1) / 2);
        const tableY = r.y0 + 3;
        furn.tables.push({ x: tableX, y: tableY });

        // key near the table
        const kx = tableX;
        const ky = tableY + 1;
        if (inBounds(kx, ky)) world[ky][kx] = T_KEY;
      }

      // Infirmary furniture
      if (rooms.infirmary) {
        const r = rooms.infirmary;
        furn.medBeds.push({ x: r.x0 + 1, y: r.y0 + 2 });
        furn.medBeds.push({ x: r.x0 + 1, y: r.y0 + 4 });
        furn.medShelves.push({ x: r.x1 - 2, y: r.y0 + 2 });
      }

      // Laboratory furniture (lab table + shelf)
      if (rooms.laboratory) {
        const r = rooms.laboratory;
        const tableX = Math.floor((r.x0 + r.x1) / 2);
        const tableY = r.y0 + 3;
        furn.tables.push({ x: tableX, y: tableY });

        furn.medShelves.push({ x: r.x0 + 1, y: r.y0 + 1 });
      }

      // Throne room throne & closets near entrance
      if (rooms.throne) {
        const r = rooms.throne;
        const throneX = Math.floor((r.x0 + r.x1) / 2);
        const throneY = r.y0 + 1;
        // actual throne tile already marked T_THRONE, we just draw the sprite higher
        // closets at entrance sides
        const entryY = r.y0 + 3;
        const leftClosetX = r.x0 + 2;
        const rightClosetX = r.x1 - 2;
        furn.closets.push({ x: leftClosetX, y: entryY });
        furn.closets.push({ x: rightClosetX, y: entryY });
        world[entryY][leftClosetX] = T_CLOSET;
        world[entryY][rightClosetX] = T_CLOSET;
      }

      // One extra hallway closet mid hallway
      const midClosetX = cx - 2;
      const midClosetY = Math.floor((hallTop + hallBottom) / 2);
      furn.closets.push({ x: midClosetX, y: midClosetY });
      world[midClosetY][midClosetX] = T_CLOSET;
    }

    generateCastle();

    function findTile(type) {
      for (let y = 0; y < WORLD_H; y++) {
        for (let x = 0; x < WORLD_W; x++) {
          if (world[y][x] === type) return { x, y };
        }
      }
      return null;
    }

    // ===== Game reset =====
    function resetGame() {
      const startTile = findTile(T_START) || { x: 2, y: 2 };
      player.x = (startTile.x + 0.5) * TILE;
      player.y = (startTile.y + 0.5) * TILE;
      player.vx = player.vy = 0;
      playerFacing = "down";

      const throneTile = findTile(T_THRONE) || { x: Math.floor(WORLD_W / 2), y: WORLD_H - 6 };
      horiver.x = (throneTile.x + 0.5) * TILE;
      horiver.y = (throneTile.y + 0.5) * TILE;
      horiver.vx = horiver.vy = 0;
      horiver.active = false;
      horiver.alive = true;
      horiver.state = "patrol";
      horiver.patrolIndex = 0;
      horiver.lastKnownX = horiver.x;
      horiver.lastKnownY = horiver.y;
      horiver.searchTimer = 0;
      horiver.timeSinceSeen = 0;
      horiverFacingVec = { x: 0, y: 1 };

      haveFlashlight = false;
      haveKey = false;
      haveVape = false;
      vapeDestroyed = false;
      gameOver = false;
      win = false;
      playerHidden = false;
      closetNearby = false;
      closetTile = null;
      hideReturnPos = null;

      document.getElementById("subtitle").textContent =
        "Mission: find the flashlight, key, vape and bathroom in Hóriver’s cursed mega-mansion–castle";

      hideAlert();
      clearInteraction();
      stopFootsteps();
      stopHeartbeat();
    }

    // ===== Input =====
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keysState.w = true;
      if (k === "s") keysState.s = true;
      if (k === "a") keysState.a = true;
      if (k === "d") keysState.d = true;

      if (k === "f") {
        if (!document.getElementById("welcomeOverlay").classList.contains("active") && !gameOver && !win) {
          toggleHideInCloset();
        }
      }

      if (k === "e") {
        if (interactionAction &&
            !document.getElementById("welcomeOverlay").classList.contains("active") &&
            !gameOver && !win) {
          const fn = interactionAction;
          interactionAction = null;
          interactionPrompt = "";
          interactionEl.textContent = "";
          fn();
        }
      }
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keysState.w = false;
      if (k === "s") keysState.s = false;
      if (k === "a") keysState.a = false;
      if (k === "d") keysState.d = false;
    });

    // ===== Alert banner =====
    function showAlert() {
      const el = document.getElementById("alertBanner");
      el.style.display = "block";
      setTimeout(() => { el.style.display = "none"; }, 2000);
    }
    function hideAlert() {
      document.getElementById("alertBanner").style.display = "none";
    }

    function awakenHoriver() {
      if (!horiver.active && horiver.alive) {
        horiver.active = true;
        showAlert();
        safePlay(sounds.jumpscare);
      }
    }

    function findNearbyTile(types, px, py, range = 44) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      let best = null;
      let bestDist = Infinity;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = tx + dx;
          const ny = ty + dy;
          const t = tileAt(nx, ny);
          if (types.includes(t)) {
            const cx = (nx + 0.5) * TILE;
            const cy = (ny + 0.5) * TILE;
            const d = Math.hypot(px - cx, py - cy);
            if (d < range && d < bestDist) {
              bestDist = d;
              best = { x: nx, y:ny, tile: t };
            }
          }
        }
      }
      return best;
    }

    function pickupCheck() {
      clearInteraction();
      const px = player.x;
      const py = player.y;

      const near = findNearbyTile(
        [T_FLASHLIGHT, T_KEY, T_CHEST, T_BATHROOM, T_THRONE],
        px, py, 50
      );

      if (near) {
        const { x: tx, y: ty, tile: t } = near;

        if (t === T_FLASHLIGHT && !haveFlashlight) {
          interactionPrompt = "Press E to pick up flashlight";
          interactionAction = () => {
            haveFlashlight = true;
            world[ty][tx] = T_FLOOR;
            safePlay(sounds.pickup);
            document.getElementById("subtitle").textContent =
              "Mission: find the key to Hóriver’s vape chest";
          };
        }

        if (t === T_KEY && !haveKey) {
          interactionPrompt = "Press E to pick up key";
          interactionAction = () => {
            haveKey = true;
            world[ty][tx] = T_FLOOR;
            safePlay(sounds.pickup);
            awakenHoriver();
            document.getElementById("subtitle").textContent =
              "Mission: reach the chest in the armory and steal the vape";
          };
        }

        if (t === T_CHEST && haveKey && !haveVape && !vapeDestroyed) {
          interactionPrompt = "Press E to steal Hóriver's vape";
          interactionAction = () => {
            haveVape = true;
            safePlay(sounds.door);
            safePlay(sounds.pickup);
            document.getElementById("subtitle").textContent =
              "Mission: find the bathroom and flush the vape";
          };
        }

        if (t === T_BATHROOM && haveVape && !vapeDestroyed) {
          interactionPrompt = "Press E to flush the vape";
          interactionAction = () => {
            haveVape = false;
            vapeDestroyed = true;
            safePlay(sounds.flush);
            safePlay(sounds.deathScream);
            horiver.alive = false;
            horiver.active = false;
            stopHeartbeat();
            document.getElementById("subtitle").textContent =
              "Mission: return to the throne to claim your reward";
          };
        }

        if (t === T_THRONE && vapeDestroyed && !win) {
          interactionPrompt = "Press E to claim your reward";
          interactionAction = () => {
            finishLevel();
          };
        }
      }

      // closets
      closetNearby = false;
      closetTile = null;
      const nearCloset = findNearbyTile([T_CLOSET], px, py, 50);
      if (nearCloset) {
        closetNearby = true;
        closetTile = { x: nearCloset.x, y: nearCloset.y };
        const closetMsg = playerHidden
          ? "Press F to leave closet"
          : "Press F to hide in closet";
        if (!interactionPrompt) interactionPrompt = closetMsg;
        else interactionPrompt += " | " + closetMsg;
      }

      interactionEl.textContent = interactionPrompt;
    }

    function finishLevel() {
      win = true;
      safePlay(sounds.win);
      document.getElementById("winOverlay").classList.add("active");
      clearInteraction();
      stopFootsteps();
      stopHeartbeat();
    }

    function killPlayer() {
      if (gameOver || win) return;
      gameOver = true;
      safePlay(sounds.jumpscare);
      document.getElementById("deathOverlay").classList.add("active");
      clearInteraction();
      stopFootsteps();
      stopHeartbeat();
    }

    function moveEntity(ent, dt) {
      const nextX = ent.x + ent.vx * dt;
      const nextY = ent.y + ent.vy * dt;

      const txNewX = Math.floor(nextX / TILE);
      const tyCur = Math.floor(ent.y / TILE);
      if (isWalkable(txNewX, tyCur)) ent.x = nextX;
      else ent.vx = 0;

      const txCur = Math.floor(ent.x / TILE);
      const tyNewY = Math.floor(nextY / TILE);
      if (isWalkable(txCur, tyNewY)) ent.y = nextY;
      else ent.vy = 0;
    }

    function toggleHideInCloset() {
      if (playerHidden) {
        playerHidden = false;
        if (hideReturnPos) {
          player.x = hideReturnPos.x;
          player.y = hideReturnPos.y;
        }
        hideReturnPos = null;
        interactionPrompt = "";
        interactionEl.textContent = "";
        return;
      }
      if (!closetNearby || !closetTile) return;
      playerHidden = true;
      hideReturnPos = { x: player.x, y: player.y };
      player.vx = player.vy = 0;
      horiver.timeSinceSeen = 999;
      horiver.searchTimer = 0;
      interactionPrompt = "Hidden in closet. Press F to leave.";
      interactionEl.textContent = interactionPrompt;
    }

    function updateMovement(dt) {
      if (playerHidden) {
        player.vx = player.vy = 0;
        stopFootsteps();
        pickupCheck();
        return;
      }
      let dx = 0, dy = 0;
      if (keysState.w) dy -= 1;
      if (keysState.s) dy += 1;
      if (keysState.a) dx -= 1;
      if (keysState.d) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len; dy /= len;
        player.vx = dx * playerSpeed;
        player.vy = dy * playerSpeed;

        // facing
        if (Math.abs(dx) > Math.abs(dy)) {
          playerFacing = dx > 0 ? "right" : "left";
        } else {
          playerFacing = dy > 0 ? "down" : "up";
        }

        playFootsteps();
      } else {
        player.vx = player.vy = 0;
        stopFootsteps();
      }

      moveEntity(player, dt);
      pickupCheck();
    }

    function setHoriverState(st) {
      if (horiver.state === st) return;
      const prev = horiver.state;
      horiver.state = st;
      if (st === "chase") playHeartbeat();
      else if (prev === "chase" && st !== "chase") stopHeartbeat();
    }

    function canHoriverSeePlayer() {
      if (!horiver.alive || !horiver.active) return false;
      if (playerHidden) return false;
      const dx = player.x - horiver.x;
      const dy = player.y - horiver.y;
      const dist = Math.hypot(dx, dy);
      const visionRange = 320; // moderate range
      if (dist > visionRange) return false;

      const dirX = dx / dist;
      const dirY = dy / dist;
      const f = horiverFacingVec;
      const dot = dirX * f.x + dirY * f.y;

      // 200° FOV -> half-angle 100°
      const fov = 200 * Math.PI / 180;
      const coneCos = Math.cos(fov / 2);
      return dot > coneCos;
    }

    function updateHoriver(dt) {
      if (!horiver.active || !horiver.alive) return;
      const sees = canHoriverSeePlayer();
      if (sees) {
        horiver.timeSinceSeen = 0;
        horiver.lastKnownX = player.x;
        horiver.lastKnownY = player.y;
        setHoriverState("chase");
      } else {
        horiver.timeSinceSeen += dt;
      }

      const base = horiverBaseSpeed;
      let targetX = horiver.x;
      let targetY = horiver.y;
      let speed = base;

      if (horiver.state === "patrol") {
        if (!patrolPoints.length) {
          targetX = player.x;
          targetY = player.y;
          speed = base * 0.7;
        } else {
          const p = patrolPoints[horiver.patrolIndex % patrolPoints.length];
          targetX = (p.x + 0.5) * TILE;
          targetY = (p.y + 0.5) * TILE;
          speed = base * 0.6;
          const dpx = targetX - horiver.x;
          const dpy = targetY - horiver.y;
          if (Math.hypot(dpx, dpy) < 10) {
            horiver.patrolIndex = (horiver.patrolIndex + 1) % patrolPoints.length;
          }
        }
      } else if (horiver.state === "chase") {
        targetX = player.x;
        targetY = player.y;
        speed = base * 1.6;
        if (horiver.timeSinceSeen > 3) {
          setHoriverState("search");
          horiver.searchTimer = 0;
        }
      } else if (horiver.state === "search") {
        targetX = horiver.lastKnownX;
        targetY = horiver.lastKnownY;
        speed = base * 0.9;
        const ddx = targetX - horiver.x;
        const ddy = targetY - horiver.y;
        if (Math.hypot(ddx, ddy) < 12) {
          horiver.searchTimer += dt;
          if (horiver.searchTimer > 5) {
            setHoriverState("patrol");
            horiver.searchTimer = 0;
          }
        }
      }

      const mdx = targetX - horiver.x;
      const mdy = targetY - horiver.y;
      const mdist = Math.hypot(mdx, mdy) || 1;
      if (mdist > 1) {
        const vx = (mdx / mdist) * speed;
        const vy = (mdy / mdist) * speed;
        horiver.vx = vx;
        horiver.vy = vy;
        horiverFacingVec.x = mdx / mdist;
        horiverFacingVec.y = mdy / mdist;
      } else {
        horiver.vx = 0;
        horiver.vy = 0;
      }

      moveEntity(horiver, dt);

      const ptx = Math.floor(player.x / TILE);
      const pty = Math.floor(player.y / TILE);
      const htx = Math.floor(horiver.x / TILE);
      const hty = Math.floor(horiver.y / TILE);
      if (ptx === htx && pty === hty && !playerHidden && !vapeDestroyed) {
        killPlayer();
      }
    }

    function getCamera() {
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      const maxX = WORLD_W * TILE - canvas.width;
      const maxY = WORLD_H * TILE - canvas.height;
      camX = Math.max(0, Math.min(camX, maxX));
      camY = Math.max(0, Math.min(camY, maxY));
      return { x: camX, y: camY };
    }

    function drawImageTile(img, dx, dy) {
      if (!img.complete || !img.naturalWidth) {
        return;
      }
      ctx.drawImage(img, 0, 0, 32, 32, dx, dy, TILE, TILE);
    }

    function render() {
      const cam = getCamera();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const startTX = Math.floor(cam.x / TILE);
      const startTY = Math.floor(cam.y / TILE);
      const endTX = Math.ceil((cam.x + canvas.width) / TILE);
      const endTY = Math.ceil((cam.y + canvas.height) / TILE);

      // tiles
      for (let ty = startTY; ty <= endTY; ty++) {
        for (let tx = startTX; tx <= endTX; tx++) {
          const t = tileAt(tx, ty);
          const sx = tx * TILE - cam.x;
          const sy = ty * TILE - cam.y;

          if (t === T_WALL) {
            // walls: solid dark cobble
            drawImageTile(imgCobbleDark, sx, sy);
          } else {
            // floors: cobble with occasional crack
            const r = coordRand(tx, ty);
            if (r < 0.18) {
              drawImageTile(imgCobbleCrack, sx, sy);
            } else {
              drawImageTile(imgCobble, sx, sy);
            }
          }
        }
      }

      // furniture (non-interactive) – draw after floors
      function drawFurnitureArray(arr, img, offsetY = 0, scale = 1) {
        if (!img.complete || !img.naturalWidth) return;
        const size = TILE * scale;
        for (const f of arr) {
          const sx = f.x * TILE - cam.x;
          const sy = f.y * TILE - cam.y + offsetY;
          ctx.drawImage(img, 0, 0, 32, 32, sx, sy, size, size);
        }
      }

      drawFurnitureArray(furn.beds, imgBed);
      drawFurnitureArray(furn.stoves, imgStove);
      drawFurnitureArray(furn.tables, imgTable);
      drawFurnitureArray(furn.armorStands, imgArmorStand);
      drawFurnitureArray(furn.weaponStands, imgWeaponStand);
      drawFurnitureArray(furn.medBeds, imgMedBed);
      drawFurnitureArray(furn.medShelves, imgMedShelf);

      // bathroom fixtures
      drawFurnitureArray(furn.sinks, imgSink);
      drawFurnitureArray(furn.baths, imgBath);
      drawFurnitureArray(furn.toilets, imgToilet);

      // closets (also interactive tiles)
      if (imgCloset.complete && imgCloset.naturalWidth) {
        for (const c of furn.closets) {
          const sx = c.x * TILE - cam.x;
          const sy = c.y * TILE - cam.y - TILE * 0.25;
          ctx.drawImage(imgCloset, 0, 0, 32, 32, sx, sy, TILE, TILE * 1.25);
        }
      }

      // throne sprite
      if (rooms.throne && imgThrone.complete && imgThrone.naturalWidth) {
        const r = rooms.throne;
        const throneX = Math.floor((r.x0 + r.x1) / 2);
        const throneY = r.y0 + 1;
        const sx = throneX * TILE - cam.x;
        const sy = throneY * TILE - cam.y - TILE * 0.5;
        ctx.drawImage(imgThrone, 0, 0, 32, 32, sx, sy, TILE, TILE * 1.5);
      }

      // items
      for (let ty = startTY; ty <= endTY; ty++) {
        for (let tx = startTX; tx <= endTX; tx++) {
          const t = tileAt(tx, ty);
          const gx = tx * TILE;
          const gy = ty * TILE;
          const sx = gx - cam.x;
          const sy = gy - cam.y;

          function drawSpriteAt(img, scale = 0.95) {
            const size = TILE * scale;
            const dx = sx + (TILE - size) / 2;
            const dy = sy + (TILE - size) / 2;
            if (img.complete && img.naturalWidth) {
              ctx.drawImage(img, 0, 0, 32, 32, dx, dy, size, size);
            }
          }

          if (t === T_FLASHLIGHT && !haveFlashlight) drawSpriteAt(imgFlashlight);
          if (t === T_KEY && !haveKey) drawSpriteAt(imgKey);
          if (t === T_CHEST && haveKey && !vapeDestroyed && !haveVape) {
            // table already drawn, just show vape sprite
            drawSpriteAt(imgVape);
          }
        }
      }

      // player
      function drawSprite(img, worldX, worldY, scale) {
        const screenX = worldX * TILE - cam.x;
        const screenY = worldY * TILE - cam.y;
        const size = TILE * scale;
        const dx = screenX + (TILE - size) / 2;
        const dy = screenY + (TILE - size) / 2;
        if (screenX + TILE < 0 || screenY + TILE < 0 ||
            screenX > canvas.width || screenY > canvas.height) return;
        if (img.complete && img.naturalWidth) {
          ctx.drawImage(img, 0, 0, 32, 32, dx, dy, size, size);
        }
      }

      if (!playerHidden) {
        let pImg = imgPlayerDown;
        if (playerFacing === "up") pImg = imgPlayerUp;
        else if (playerFacing === "down") pImg = imgPlayerDown;
        else if (playerFacing === "left") pImg = imgPlayerLeft;
        else if (playerFacing === "right") pImg = imgPlayerRight;
        drawSprite(pImg, player.x / TILE, player.y / TILE, 0.95);
      }

      // horiver – 2x bigger
      if (horiver.alive && horiver.active) {
        let hImg = imgHoriverDown;
        if (Math.abs(horiverFacingVec.x) > Math.abs(horiverFacingVec.y)) {
          hImg = horiverFacingVec.x < 0 ? imgHoriverLeft : imgHoriverRight;
        } else {
          hImg = horiverFacingVec.y < 0 ? imgHoriverUp : imgHoriverDown;
        }
        drawSprite(hImg, horiver.x / TILE, horiver.y / TILE, 2.0);
      }

      applyFog(player.x - cam.x, player.y - cam.y);
      drawHUD();
    }

    function drawHUD() {
      const size = 22;
      let x = 10;
      const y = canvas.height - size - 8;

      function drawIcon(img, have) {
        ctx.save();
        ctx.globalAlpha = have ? 1.0 : 0.25;
        if (img.complete && img.naturalWidth) {
          ctx.drawImage(img, 0, 0, 32, 32, x, y, size, size);
        } else {
          ctx.fillStyle = have ? "#ffe696" : "#555";
          ctx.fillRect(x, y, size, size);
        }
        ctx.restore();
        x += size + 6;
      }

      drawIcon(imgHUDFlashlight, haveFlashlight);
      drawIcon(imgHUDKey, haveKey);
      drawIcon(imgHUDVape, haveVape);
      drawIcon(imgHUDToken, vapeDestroyed);
    }

    // flashlight cone based on player facing, not mouse
    function applyFog(pScreenX, pScreenY) {
      ctx.save();

      // base darkness radial gradient
      const outerRadius = haveFlashlight ? 260 : 180;
      const g = ctx.createRadialGradient(
        pScreenX, pScreenY, 0,
        pScreenX, pScreenY, outerRadius
      );
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(0.7, "rgba(0,0,0,0.45)");
      g.addColorStop(1, "rgba(0,0,0,0.96)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (haveFlashlight) {
        // cut out a cone in front of the player
        ctx.globalCompositeOperation = "destination-out";

        let dirX = 0, dirY = 1;
        if (playerFacing === "up") { dirX = 0; dirY = -1; }
        else if (playerFacing === "down") { dirX = 0; dirY = 1; }
        else if (playerFacing === "left") { dirX = -1; dirY = 0; }
        else if (playerFacing === "right") { dirX = 1; dirY = 0; }

        const coneLength = 420;
        const coneWidth = Math.PI / 9; // fairly tight cone

        const angle = Math.atan2(dirY, dirX);
        const a1 = angle - coneWidth;
        const a2 = angle + coneWidth;

        const tip1x = pScreenX + Math.cos(a1) * coneLength;
        const tip1y = pScreenY + Math.sin(a1) * coneLength;
        const tip2x = pScreenX + Math.cos(a2) * coneLength;
        const tip2y = pScreenY + Math.sin(a2) * coneLength;

        ctx.beginPath();
        ctx.moveTo(pScreenX, pScreenY);
        ctx.lineTo(tip1x, tip1y);
        ctx.lineTo(tip2x, tip2y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0,0,0,0.98)";
        ctx.fill();
      }

      ctx.restore();
    }

    // ===== Main loop =====
    let lastTime = performance.now();
    function loop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;

      if (!gameOver && !win && !document.getElementById("welcomeOverlay").classList.contains("active")) {
        updateMovement(dt);
        updateHoriver(dt);
        render();
      } else {
        render();
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== Overlays & intro =====
    const welcomeOverlay = document.getElementById("welcomeOverlay");
    const welcomeCard = document.getElementById("welcomeCard");
    const welcomeTextEl = document.getElementById("welcomeText");
    const welcomeHintEl = document.getElementById("welcomeHint");
    const welcomeTextWrapper = document.getElementById("welcomeTextWrapper");
    const welcomeFinal = document.getElementById("welcomeFinal");
    const enterBtn = document.getElementById("enterBtn");

    const deathOverlay = document.getElementById("deathOverlay");
    const winOverlay = document.getElementById("winOverlay");

    const welcomeMessages = [
      "Welcome to Hubios communism party game. Your mission is to save communism Iceland, but first, you need to defeat some foes...",
      "Now you'll enter... Horiver's lair!!!",
      "Are you ready?"
    ];
    let welcomeStep = 0;
    let typingIndex = 0;
    let typingTimer = null;
    let typingDone = false;

    function typeNextChar() {
      const msg = welcomeMessages[welcomeStep];
      if (typingIndex <= msg.length) {
        welcomeTextEl.textContent = msg.slice(0, typingIndex);
        typingIndex++;
      } else {
        clearInterval(typingTimer);
        typingTimer = null;
        typingDone = true;
        welcomeHintEl.textContent = "Click this box to continue...";
      }
    }

    function startTyping() {
      if (typingTimer) clearInterval(typingTimer);
      typingIndex = 0;
      typingDone = false;
      welcomeTextEl.textContent = "";
      welcomeHintEl.textContent = "";
      typingTimer = setInterval(typeNextChar, 35);
    }

    startTyping();

    welcomeCard.addEventListener("click", () => {
      startMusicOnce();
      if (!typingDone) {
        const msg = welcomeMessages[welcomeStep];
        clearInterval(typingTimer);
        typingTimer = null;
        typingDone = true;
        typingIndex = msg.length;
        welcomeTextEl.textContent = msg;
        welcomeHintEl.textContent = "Click this box to continue...";
        return;
      }
      welcomeStep++;
      if (welcomeStep < welcomeMessages.length) {
        startTyping();
      } else {
        welcomeTextWrapper.style.display = "none";
        welcomeFinal.style.display = "block";
      }
    });

    enterBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      safePlay(sounds.menuClick);
      startMusicOnce();
      welcomeOverlay.classList.remove("active");
      resetGame();
      safePlay(sounds.start);
    });

    document.getElementById("retryBtn").addEventListener("click", () => {
      safePlay(sounds.menuClick);
      deathOverlay.classList.remove("active");
      resetGame();
    });

    document.getElementById("playAgainBtn").addEventListener("click", () => {
      safePlay(sounds.menuClick);
      winOverlay.classList.remove("active");
      resetGame();
    });
  </script>
</body>
</html>
